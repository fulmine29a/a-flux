/***
 * создание стора
 */

import {AfluxReducers, AfluxState, Immutable} from "./types";
import {createSubscribeNode} from "./subscribes";

// список всех сторов для возможности реализации девтула
// @ts-ignore
global.storeList = [];

export function createStore<S extends AfluxState, R extends AfluxReducers<S>, Reducers = {[k in keyof R]: ( payload?: Parameters<R[k]>[1]) => void}>(initialState: S, reducersTemplate: R, storeName = '', debug = false) {
  /*
   начальное состояние инициализируем тут, а не прогоняя редуцер впустую.

   в редакс использование начального стейта как значения по умолчанию имеет сл. причины:
   - при сборке одного огромного стора из кучи редуцеров это делает сборку стора более простым (вот редуцер и вот его стейт)
   - при отсутствии типизации это даёт подсказку для IDE какие данные в state
   - эдакий файл-сейф если всё обнулиться
   ...возможно что-то ещё до чего я не додумался...

   у нас же:
   - имеем несколько разных сторов, а значит начальное состояние конкретному стору можно просто указать
     при создании, т.к. отпадает необходимость во вложенных сторах (нужен "подстор" - просто делаем новый стор)
   - типизация у нас явная
  */

  // текущее состояние стора
  let currentState = initialState;

  /*
    получение состояния стора.

    для предупреждения случайной мутации стора помечаем возврашаемое состояние в typescript как неизменяемое,
    но не замораживаем фактически, т.к. это повлечёт создание копии объекта в памяти, что при каждом запросе нам не нужно
  */
  const getState = () => currentState as unknown as Immutable<S>;

  // создаём узел подписки

  const {emit, subscribe} = createSubscribeNode();

  /*
    формируем преобразователи (редуцеры).

    типичная структура написания редуцеров в редакс мне не нравится:
    - сначала объявляем константы, потом пишем километровый свитч и путаемся в переменных если они вдруг понадобились.
    - сложность в описании типов параметров редуцеров передаваемых через dispatch порождает необходимость
      в ещё в одной сушности actionCreator-ы, которые мало того что надо описывать, так и ещё и сбивают
      с толку при попытке понять их назначение. actionCreator по началу кажется местом для бизнес логики,
      только вот какая она без асинхроности и нескольких преобразований(показать лоадер, что-то положить в стор, убрать лоадер)?
      всё что может actionCreator - это быть способом типизации преобразований.
    - встаёт проблема объяснить IDE что же мы там можем передать в type у dispatch.

    в нашем случае кладём все редуцеры в один объект, ключ - по сути TYPE нужного преобразования и получаем:
    - все возможные типы преобразований указаны явно, в итоговом объекте подсказки IDE работают, просто жмём точку
      и видим что может вызвать. и для этого даже не нужно выдумывать плагины для шторма... всё с коробки
    - параметры и их типы так же проброшены для IDE и typescript
    - DRY!!!
  */
  const reducers = Object.fromEntries(
    Object.entries(reducersTemplate).map(
      ([type, reducer]) =>
        [type, (payload?:any) => {
          const newState = reducer(currentState, payload)
          const changed = newState != currentState;

          if(debug){
            /*
              тут по идее должна быть отправка данных преобразования в девтул, записи данных для "машины времени" и хот-релоада...
              для демонстрации ограничимся выводом в консоль
            */

            console.table(
              {
                storeName,
                TYPE: type,
                PAYLOAD: payload,
                changed,
                // выводим копии объектов, на случай если потом была мутация это даст понять что проблема не тут.
                new: JSON.parse(JSON.stringify(newState)),
                old: JSON.parse(JSON.stringify(currentState)),
              },
            )
          }

          if(changed){
            currentState = newState;

            emit();
          }
        }]
    )
  ) as unknown as Reducers;

  const store = {
    getState,
    reducers,
    storeName,
    subscribe,
  };

  if(debug){
    // @ts-ignore
    global.storeList.push(store);
  }

  return store;
}
